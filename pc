#!/bin/bash

set -o nounset

#  Helper that describes all functionalities
# =============================================

if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]]; then
    echo "$(basename "$0") [-h] [-e env -b backend c] -- program to deal with Pass Culture ecosystem
where:
    -h  show this help text
    -e  specify environment to target (default: development)
    -b  specify backend to connect with local app (default: localhost)
    -t  specify version you want to deploy (create tag with this name)
    c   command that you want to run"
    exit 0
fi


# =============================================
# Get script parameters
# =============================================

if [[ $# -gt 2 ]] && [[ "$1" == "-e" ]]; then
  ENV=$2
  shift 2
else
  ENV=${ENV:-'development'}
fi

if [[ $# -gt 2 ]] && [[ "$1" == "-b" ]]; then
  BACKEND=$2
  shift 2
else
  BACKEND=${BACKEND:-'localhost'}
fi

if [[ $# -gt 2 ]] && [[ "$1" == "-t" ]]; then

  if [[ "$2" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
    TAG_NAME=$2
  else
    echo "tag format should be semver compliant (vx.x.x)"
  fi

  shift 2
fi

CMD="$1"

# =============================================
# Set variables for env
# =============================================

if [[ "$ENV" == "production" ]]; then
	SCALINGO_APP=pass-culture-api
elif [[ "$ENV" == "staging" ]]; then
	SCALINGO_APP=pass-culture-api-staging
elif [[ "$ENV" == "testing" ]]; then
	SCALINGO_APP=pass-culture-api-dev
elif [[ "$ENV" == "demo" ]]; then
	SCALINGO_APP=pass-culture-api-demo
elif [[ "$ENV" == "integration" ]]; then
	SCALINGO_APP=pass-culture-api-integration
fi

# =============================================
# Utilities functions
# =============================================
PRG="$BASH_SOURCE"

while [ -h "$PRG" ] ; do
	ls=$(ls -ld "$PRG")
	link=$(expr "$ls" : '.*-> \(.*\)$')
	if expr "$link" : '/.*' > /dev/null; then
		PRG="$link"
	else
		PRG=$(dirname "$PRG")"/$link"
	fi
done

ROOT_PATH=$(realpath "$(dirname "$PRG")")

function confirm {
 read -p "$1 (y/n) : " -n 1 -r
 echo
 if [[ ! $REPLY =~ ^[Yy]$ ]]
 then
   exit
 fi
}

function ensure_remote {
  if [[ "$ENV" == "development" ]]; then
    echo "$1"
    exit 3
  fi
}

current_branch=$(git symbolic-ref -q HEAD)
current_branch=${current_branch##refs/heads/}

commit_to_deploy=$(git log -n 1 --pretty=format:%H)

function exit_restoring_branch {
  git checkout "$current_branch"
  exit
}

# =============================================
# Local commands : use Docker
# =============================================

# Run alembic migration
# Need to specify what alembic command you want to execute
# Example: ./pc alembic upgrade HEAD
if [[ "$CMD" == "alembic" ]]; then
  RUN='docker exec `docker ps | grep flask | cut -d" " -f 1` bash -c "cd /opt/services/flaskapp/src && PYTHONPATH=. alembic '"$*"'"'

# Connect to API container
elif [[ "$CMD" == "bash" ]]; then
  RUN='docker exec -it `docker ps | grep flask | cut -d" " -f 1` bash'

# Create diff output between schema in staging & local backend
elif [[ "$CMD" == "diff-schema" ]]; then
  docker exec "$(docker ps | grep postgres | cut -d" " -f 1)" pg_dump -d pass_culture -U pass_culture -s > /tmp/pc_schema_local
  scalingo -a pass-culture-api-staging run 'dbclient-fetcher postgresql 10.4 && pg_dump "$SCALINGO_POSTGRESQL_URL" -s' > /tmp/pc_schema_staging
  diff /tmp/pc_schema_staging /tmp/pc_schema_local
  exit

# Dump pass_culture database into pgdump file
elif [[ "$CMD" == "dump-db" ]]; then
  RUN='mkdir -p "$ROOT_PATH/db_dumps";
       docker exec `docker ps | grep postgres | cut -d" " -f 1` pg_dump -d pass_culture -U pass_culture -F c > "$ROOT_PATH"/db_dumps/`date +%Y%m%d_%H%M%S`.pgdump'

# Force docker-compose to build the docker images
elif [[ "$CMD" == "rebuild-backend" ]]; then
  RUN='docker-compose build --no-cache;
			 sudo rm -rf $ROOT_PATH/api/static/object_store_data;
       sudo rm -rf $ROOT_PATH/api/postgres_data'

# Execute request from specified file
elif [[ "$CMD" == "psql-file" ]]; then
  COLUMNS=${COLUMNS:-''};
  RUN='docker exec -t `docker ps | grep postgres | cut -d" " -f 1` bash -c "COLUMNS=\"'$COLUMNS'\" psql -U pass_culture pass_culture -f $1"'

# Restart API after removing the database and files
elif [[ "$CMD" == "restart-backend" ]]; then
  RUN='sudo rm -rf $ROOT_PATH/api/static/object_store_data;
       sudo rm -rf $ROOT_PATH/api/postgres_data;
       cd $ROOT_PATH && docker-compose up --force-recreate'

# Clear all data in postgresql database
elif [[ "$CMD" == "reset-all-db" ]]; then
  RUN='docker exec -it `docker ps | grep flask | cut -d" " -f 1` bash -c "rm -rf /opt/services/flaskapp/src/static/object_store_data/*";
       docker exec -it `docker ps | grep postgres | cut -d" " -f 1` bash -c "psql -U pass_culture pass_culture -c \"TRUNCATE \\\"user\\\",booking,offerer,event,mediation,offer,provider,recommendation,user_offerer,venue,thing RESTART IDENTITY CASCADE;\""'

# Remove all booking & reco from database
elif [[ "$CMD" == "reset-reco-db" ]]; then
  RUN='docker exec -it `docker ps | grep postgres | cut -d" " -f 1` bash -c "psql -U pass_culture pass_culture -c \"TRUNCATE booking,recommendation RESTART IDENTITY;\""'

# Remove all booking, reco & user_offerer from database
elif [[ "$CMD" == "reset-users-db" ]]; then
  RUN='docker exec -it `docker ps | grep postgres | cut -d" " -f 1` bash -c "psql -U pass_culture pass_culture -c \"TRUNCATE \\\"user\\\",booking,recommendation,user_offerer RESTART IDENTITY CASCADE;\""'

# Delete all local images
elif [[ "$CMD" == "reset-all-storage" ]]; then
  RUN='sudo rm -rf $ROOT_PATH/flask/static/object_store_data;'

# Restore a postgresql database from file
elif [[ "$CMD" == "restore-db" ]]; then
  echo "Warning : RUN reset-all-db before running this !"
  if [[ $# == 0 ]]; then
    echo "Usage : pc restore-db <backup_file> [arguments]"
    exit
  fi
  backup_file="$1"
  RUN='cat "'$backup_file'" | docker exec -i `docker ps | grep postgres | cut -d" " -f 1` pg_restore -d pass_culture -U pass_culture -c'

# Prepare backend for local use
elif [[ "$CMD" == "set-backend" ]]; then
  RUN='cd "$ROOT_PATH";
			 ./pc update-mocks;
			 ./pc update_providables -m -p SpreadsheetExpVenues;
			 ./pc update_providables -m -p SpreadsheetExpOffers;
			 ./pc sandbox --name=light;
			'
# Start API server with database and nginx server
elif [[ "$CMD" == "start-backend" ]]; then
  RUN='cd $ROOT_PATH && docker-compose up'

# Start webapp or pro application
elif [[ "$CMD" == "start-webapp" ]] || [[ "$CMD" == "start-pro" ]]; then
  if [[ "$CMD" == "start-webapp" ]]; then
    RUN='cd $ROOT_PATH/webapp'
  else
    RUN='cd $ROOT_PATH/pro'
  fi
  if [[ "$BACKEND" == "testing" ]]; then
    RUN="$RUN"' && export THUMBS_URL=https://storage.gra3.cloud.ovh.net/v1/AUTH_810600e32fdc4cb49a8d15332b68d2cc/storage-pc/thumbs && export API_URL=https://backend.passculture-testing.beta.gouv.fr'
  elif [[ "$BACKEND" == "ngrok" ]]; then
    RUN="$RUN"' && NGROK_API_URL='$(node "$ROOT_PATH"/webapp/scripts/ngrok.js)
  elif [[ "$BACKEND" != "localhost" ]]; then
    echo "Can only set backend as localhost or testing for developping your front app."
    exit
  fi
  RUN="$RUN"' && yarn start'

# TODO:
elif [[ "$CMD" == "shared" ]]; then
  RUN='cd $ROOT_PATH/shared && yarn run compile;
			 cd $ROOT_PATH/webapp/node_modules && ln -sf ../../shared pass-culture-shared;
			 cd $ROOT_PATH/pro/node_modules && ln -sf ../../shared pass-culture-shared;'

# Run tests for API
# Need start-backend to be successful and delete all data
elif [[ "$CMD" == "test-backend" ]]; then
  if [[ $# == 0 ]]; then
    confirm "Warning: your database will be wiped. Is this OK ?"
     "$ROOT_PATH"/pc -e "$ENV" reset-all-db
     RUN='docker exec `docker ps | grep flask | cut -d" " -f 1` bash -c "cd /opt/services/flaskapp/src/ && rm -rf static/object_store_data/thumbs/* && PYTHONPATH=. pytest --color=yes -rsx -v tests"'
  else
     RUN='docker exec `docker ps | grep flask | cut -d" " -f 1` bash -c "cd /opt/services/flaskapp/src/ && rm -rf static/object_store_data/thumbs/* && PYTHONPATH=. pytest --color=yes -rsx -v '"$*"'"'
  fi

# Run only local providers tests for API
elif [[ "$CMD" == "test-backend-provider" ]]; then
	RUN='"$ROOT_PATH"/pc test-backend tests/10_local_providers.py::test_15_spreadsheet_exp_venue_provider tests/10_local_providers.py::test_15_spreadsheet_exp_stocks_provider tests/10_local_providers.py::test_16_openagenda_events_provider'

# Run functional tests for webapp or pro application
# Need to run start-backend & start-frontend
elif [[ "$CMD" == "test-cafe-webapp" ]] || [[ "$CMD" == "test-cafe-pro" ]]; then
	if [[ "$CMD" == "test-cafe-webapp"  ]]; then
		APP_PATH="$ROOT_PATH"/webapp
		SANDBOX_NAME="webapp"
	else
		APP_PATH="$ROOT_PATH"/pro
		SANDBOX_NAME="light"
	fi
	if [[ $# == 0 ]]; then
		confirm "Warning: your database will be wiped. Is this OK ?"
	 	"$ROOT_PATH"/pc -e "$ENV" reset-all-db
		"$ROOT_PATH"/pc -e "$ENV" sandbox --name="$SANDBOX_NAME"
		RUN='cd $APP_PATH && ./scripts/pc.js testcafe '
	else
  	    RUN='cd $APP_PATH && ./scripts/pc.js testcafe '"$*"
	fi

# =============================================
# Deploy commands
# =============================================

# Deploy current version of API/Webapp/Pro to specified environment
elif [[ "$CMD" == "deploy-backend" ]] \
     || [[ "$CMD" == "deploy-frontend-webapp" ]] \
     || [[ "$CMD" == "deploy-frontend-pro" ]]; then

  ensure_remote "Deploy backend cannot be run on the local environment. Use (for example) \"pc -e staging "$CMD"\"."

  if [[ ! "$ENV" == 'production' ]] \
        && [[ ! "$ENV" == 'staging' ]] \
        && [[ ! "$ENV" == 'demo' ]] \
        && [[ ! "$ENV" == 'integration' ]]; then
     echo "Can only deploy-backend in staging, demo, integration and production"
     exit
  fi

  if [[ "$CMD" == "deploy-frontend-webapp"  ]]; then
	APP_PATH="$ROOT_PATH"/webapp
  elif [[ "$CMD" == "deploy-frontend-pro"  ]]; then
    APP_PATH="$ROOT_PATH"/pro
  else
	APP_PATH="$ROOT_PATH"/api
  fi

  cd "$APP_PATH"

  git fetch
  git checkout master
  git pull || exit_restoring_branch
  git checkout staging
  git pull || exit_restoring_branch
  git checkout demo
  git pull || exit_restoring_branch
  git checkout integration
  git pull || exit_restoring_branch
  git checkout production
  git pull || exit_restoring_branch

  if [[ "$TAG_NAME" ]]; then
    git tag "$TAG_NAME"
    git push origin "$TAG_NAME"
  fi

  if [[ $(git tag -l --points-at $commit_to_deploy | wc -l) == 0 ]]; then
    echo "ERROR: Can only deploy tagged commits"
    exit_restoring_branch
  fi

  if [[ "$ENV" == "production" ]]; then
    staging_commit=$(git log -n 1 --pretty=format:%H staging)
    if [[ "$staging_commit" != "$commit_to_deploy" ]]; then
      echo "ERROR: Can only deploy in production commits that are also deployed in staging"
      exit_restoring_branch
    fi
  fi

  git checkout "$ENV"
  git merge "$commit_to_deploy"
  git push origin "$ENV"

  # TODO: until I connect the app in Netlify with Github hooks
  if [[ "$CMD" == "deploy-frontend-webapp" ]] \
     || [[ "$CMD" == "deploy-frontend-pro" ]]; then
    netlify deploy -e "$ENV"
  fi

  if [[ "$ENV" == 'production' ]]; then
     echo "/!\\ You just deployed to production. Was the version also delivered to integration ?"
  fi

  exit_restoring_branch

# =============================================
# Initialization commands
# =============================================

# Install new local environment
elif [[ "$CMD" == "install" ]]; then
  RUN='cd $ROOT_PATH;
			 yarn global add concurrently;
       git submodule init;
       git submodule update;
       git submodule foreach git checkout master;
			 ./pc symlink;
			 cd $ROOT_PATH/shared && yarn install;
       cd $ROOT_PATH/webapp && yarn;
			 cd $ROOT_PATH/pro && yarn;
	   cd $ROOT_PATH && ./pc install-private;
	         ./pc install-hooks'

# Decrypt data from gpg private file
elif [[ "$CMD" == "install-private" ]]; then
  RUN='cd $ROOT_PATH/api;
            rm -rf private;
            gpg --passphrase $PC_GPG_PRIVATE --batch --output private.tar.gz -d private.tar.gz.gpg;
            tar xf private.tar.gz;
            rm private.tar.gz'

# Install local git hook for pre-push actions
elif [[ "$CMD" == "install-hooks" ]]; then
    RUN='cd $ROOT_PATH;
            ln -s -f ../../../../hooks/pre-push .git/modules/api/hooks/pre-push'

# Create symlink to use "pc" command (admin rights may be needed)
elif [[ "$CMD" == "symlink" ]]; then
  RUN='cd /usr/local/bin && ln -sf '"$(pwd)"'/pc pc && chmod +x pc && chmod +x '"$(pwd)"'/pc'

# =============================================
# Administration commands
# =============================================

# Display logs from API
elif [[ "$CMD" == "logs" ]]; then
  if [[ "$ENV" == "development" ]]; then
	docker-compose logs
	exit
  else
	if [[ $# -gt 0 ]]; then
		scalingo -a "$SCALINGO_APP" logs "$@"
	else
		scalingo -a "$SCALINGO_APP" logs -n 100
	fi
	exit
  fi

# Connect to Postgresql database in command line
elif [[ "$CMD" == "psql" ]]; then
	COLUMNS=${COLUMNS:-''};
	if [[ "$ENV" == "development" ]]; then
		RUN='docker exec -it `docker ps | grep postgres | cut -d" " -f 1` bash -c "COLUMNS=\"'$COLUMNS'\" psql -U pass_culture pass_culture $*"'
	else
		scalingo -a "$SCALINGO_APP" pgsql-console
		exit
	fi

# Open a python prompt in the specified environment
elif [[ "$CMD" == "python" ]]; then
    COLUMNS=${COLUMNS:-''};
	if [[ "$ENV" == "development" ]]; then
		RUN='docker exec -it `docker ps | grep flask | cut -d" " -f 1` bash -c "cd /opt/services/flaskapp/src/ && PYTHONPATH=. python -i scripts/interact.py '"$CMD $*"'"'
	else
		scalingo -a "$SCALINGO_APP" run "python -i scripts/interact.py"
		exit
	fi

# Connect to administration instances
elif [[ "$CMD" == "ssh" ]]; then
	if [[ "$ENV" == "production" ]]; then
		ssh deploy@api.passculture.beta.gouv.fr
	elif [[ "$ENV" == "staging" ]]; then
		ssh deploy@api.passculture-staging.beta.gouv.fr
	fi

# =============================================
# Mobile Dev commands
# =============================================

elif [[ "$CMD" == "build-pg" ]]; then
	if [[ "$ENV" == "production" ]]; then
		RUN='cd $ROOT_PATH/webapp && source ./env_file && yarn pgbuild-prod'
	else
		RUN='cd $ROOT_PATH/webapp && source ./env_file && yarn pgbuild'
	fi
elif [[ "$CMD" == "start-ios" ]]; then
	RUN='open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app'

# =============================================
# Python Scripts commands
# =============================================

# Run python scripts from api/scripts
else
  if [[ "$ENV" == "development" ]]; then
    RUN='docker exec `docker ps | grep flask | cut -d" " -f 1` bash -c "cd /opt/services/flaskapp/src/ && PYTHONPATH=. python scripts/pc.py '"$CMD $*"'"'
  else
    scalingo -a "$SCALINGO_APP" run 'python scripts/pc.py '"$CMD $*"''
    exit
  fi
fi

# =============================================
# Execute command
# =============================================

if [[ $PWD == "/home/deploy/pass-culture-main" ]]; then
	echo "$RUN"
  eval "$RUN"
else
	if [[ "$ENV" == "production" ]]; then
	  echo "$RUN" | ssh deploy@api.passculture.beta.gouv.fr bash
	elif [[ "$ENV" == "staging" ]]; then
	  echo "$RUN" | ssh deploy@api.passculture-staging.beta.gouv.fr bash
	elif [[ "$ENV" == "wordpress" ]]; then
		ssh debian@passculture.beta.gouv.fr
	else
		echo "$RUN"
	  eval "$RUN"
	fi
fi
